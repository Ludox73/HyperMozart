function fundamental_domain = fundamental_domain_S2_Ludo(param)
%FUNDAMENTAL_DOMAIN_S2 We create a fundamental domain for S2 that is a
%octagon. We parametrize the octagon in a strange way:
% param is a real value in (-1, +1). When param == 0, we have the
% standard regular octahedron.
% While param -> -1, we push the odd vertices close to the origin, and we
% change accordingly the even vertices to keep 2*pi around the point.
% While param -> +1, we do the opposite.
fundamental_domain = cell(1,8);

if param == 0
    for ind = 0:7
        fundamental_domain{ind+1} = 2^(-1/4) * [cos(pi/4*ind); sin(pi/4*ind)];
    end
    return;
elseif param<0
    odd_vertices_euclidean_norm = (param+1)/2^(-1/4)
elseif param>0
    odd_vertices_euclidean_norm = 2^(-1/4) + (param-1)/2^(1/4)
end

b = segment([1;0], [3;0]);
angle_odds = @(a) segment( odd_vertices_euclidean_norm*[1;0], a*[cos(pi/4); sin(pi/4)] ).angle(segment(odd_vertices_euclidean_norm*[1;0], a*[cos(pi/4); -sin(pi/4)]));
angle_even = @(a) b.angle(segment(a*[cos(pi/4); sin(pi/4)], odd_vertices_euclidean_norm*[1;0] ), segment(a*[cos(pi/4); sin(pi/4)], odd_vertices_euclidean_norm*[0;1] ));

to_nullify = @(ss) 2*pi-4*(angle_odds(ss)+angle_even(ss));

even_vertices_euclidean_norm = fzero(to_nullify, [0,1]);


for ind = 0:2:6
    fundamental_domain{ind+1} = odd_vertices_euclidean_norm * [cos(pi/4*ind); sin(pi/4*ind)];
end

for ind = 1:2:7
    fundamental_domain{ind+1} = even_vertices_euclidean_norm * [cos(pi/4*ind); sin(pi/4*ind)];
end
end